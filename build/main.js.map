{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["/*\n * Created with @iobroker/create-adapter v2.2.0\n */\n\n// The adapter-core module gives you access to the core ioBroker functions\n// you need to create an adapter\nimport * as utils from '@iobroker/adapter-core';\n\nimport {Device} from './lib/Device';\nimport { DeviceInfo } from './lib/DeviceInfo';\nimport { AutoDetector } from './lib/autoDetect';\nimport {TableDevice} from './lib/TableDevice';\nimport {createFromObject, createFromTable} from \"./lib/DeviceFactory\";\n\n// Load your modules here, e.g.:\n// import * as fs from \"fs\";\n\nclass Mydlink extends utils.Adapter {\n    /**\n     * Array of devices.\n     *  Device consists of:\n     *      config: which includes IP, PIN, ... set by the user\n     *      client: soapclient for interaction with device\n     * @type {Array<Device>}\n     */\n    devices: Array<Device> = [];\n\n    /**\n     * Store devices here, that we only have information from, but can not yet talk to.\n     * Especially if model is missing, and we currently can not retrieve it (because device not online)\n     * This will happen.\n     */\n    unidentifiedDevices: Array<DeviceInfo> = [];\n\n    /**\n     * Auto-detected devices. Store here and aggregate until we are sure it is mydlink and have mac\n     *  -> multiple messages.\n     * @type {{}}\n     */\n    detectedDevices : Record<string, any> = {};\n\n    autoDetector: AutoDetector | undefined = undefined;\n\n    public constructor(options: Partial<utils.AdapterOptions> = {}) {\n        super({\n            ...options,\n            name: 'mydlink',\n        });\n        this.on('ready', this.onReady.bind(this));\n        this.on('stateChange', this.onStateChange.bind(this));\n        this.on('message', this.onMessage.bind(this));\n        this.on('unload', this.onUnload.bind(this));\n    }\n\n    /**\n     * deletes all objects of an device and the device itself (deleteDeviceAsync does not work somehow...?)\n     * @param {Device} device\n     */\n    async deleteDeviceFull(device: Device) {\n        //stop device:\n        device.stop();\n\n        //check if detected device:\n        for (const ip of Object.keys(this.detectedDevices)) {\n            const dectDevice = this.detectedDevices[ip];\n            if (dectDevice.mac === device.id) {\n                dectDevice.alreadyPresent = false;\n            }\n        }\n\n        try {\n            const ids = await this.getObjectListAsync({\n                startkey: this.namespace + '.' + device.id,\n                endkey: this.namespace + '.' + device.id + '\\u9999'\n            });\n            if (ids) {\n                for (const obj of ids.rows) {\n                    await this.delObjectAsync(obj.value._id);\n                }\n            }\n        } catch (e: any) {\n            this.log.error('Error during deletion of ' + device.id + ': ' + e.stack);\n        }\n    }\n\n    /**\n     * Is called when databases are connected and adapter received configuration.\n     */\n    private async onReady(): Promise<void> {\n        // Initialize your adapter here\n\n        //get secret for decryption:\n        const systemConfig = await this.getForeignObjectAsync('system.config');\n        if (systemConfig) {\n            DeviceInfo.setSecret(systemConfig.native ? systemConfig.native.secret : 'RJaeBLRPwvPfh5O'); //fallback in case or for old installations without secret.\n        }\n\n        // Reset the connection indicator during startup\n        this.setState('info.connection', false, true);\n\n        //start auto detection:\n        this.autoDetector = new AutoDetector(this);\n\n        //start existing devices:\n        let haveActiveDevices = false;\n        const existingDevices = await this.getDevicesAsync();\n        const configDevicesToAdd = [].concat(this.config.devices) as TableDevice[];\n        this.log.debug('Got existing devices: ' + JSON.stringify(existingDevices, null, 2));\n        this.log.debug('Got config devices: ' + JSON.stringify(configDevicesToAdd, null, 2));\n        let needUpdateConfig = false;\n        for (const existingDevice of existingDevices) {\n            let found = false;\n            for (const configDevice of this.config.devices as TableDevice[]) {\n                needUpdateConfig = !configDevice.mac;\n                if ((configDevice.mac && configDevice.mac === existingDevice.native.mac) ||\n                    (!configDevice.mac && configDevice.ip === existingDevice.native.ip)) {\n                    found = true;\n\n                    //copy all data from config, because now only config is changed from config dialog.\n                    for (const key of Object.keys(configDevice)) {\n                        existingDevice.native[key] = configDevice[key]; //copy all fields.\n                    }\n                    existingDevice.native.pinNotEncrypted = !configDevice.mac;\n\n                    configDevicesToAdd.splice(configDevicesToAdd.indexOf(configDevice), 1);\n                    break; //break on first copy -> will remove additional copies later.\n                }\n            }\n            const device = await createFromObject(this, existingDevice);\n            await device.createDeviceObject(); //store new config.\n            if (existingDevice.native.pinNotEncrypted) {\n                needUpdateConfig = true;\n            }\n            if (found) {\n                haveActiveDevices = await device.start() || haveActiveDevices;\n                //keep config and client for later reference.\n                this.devices.push(device);\n            } else {\n                this.log.debug('Deleting ' + device.name);\n                await this.deleteDeviceFull(device);\n            }\n        }\n\n        //add non-existing devices from config:\n        for (const configDevice of configDevicesToAdd) {\n            const device = await createFromTable(this, configDevice, !configDevice.pinNotEncrypted);\n            this.log.debug('Device ' + device.name + ' in config but not in devices -> create and add.');\n            const oldDevice = this.devices.find(d => d.mac === device.mac);\n            if (oldDevice) {\n                this.log.info('Duplicate entry for ' + device.mac + ' in config. Trying to rectify. Restart will happen. Affected devices: ' + device.name + ' === ' + configDevice.name);\n                needUpdateConfig = true;\n            } else {\n                //make sure objects are created:\n                await device.createDeviceObject();\n\n                haveActiveDevices = await device.start() || haveActiveDevices;\n                //call this here again, to make sure it happens.\n                await device.createDeviceObject(); //store device settings\n                //keep config and client for later reference.\n                this.devices.push(device);\n            }\n        }\n\n        //try to update config:\n        if (needUpdateConfig) {\n            const devices = [];\n            for (const device of this.devices) {\n                const configDevice = {\n                    ip: device.ip,\n                    mac: device.mac,\n                    pin: device.pinEncrypted,\n                    pollInterval: device.pollInterval,\n                    enabled: device.enabled,\n                    name: device.name,\n                    model: device.model,\n                    useWebSocket: device.isWebsocket\n                };\n                devices.push(configDevice);\n            }\n            await this.extendForeignObjectAsync('system.adapter.' + this.namespace, {\n                native: {\n                    devices: devices\n                }\n            });\n        }\n\n        await this.setStateChangedAsync('info.connection', !haveActiveDevices, true); //if no active device -> make green.\n    }\n\n    /**\n     * Is called when adapter shuts down - callback has to be called under any circumstances!\n     */\n    private onUnload(callback: () => void): void {\n        try {\n            this.log.debug('Stop polling');\n            for (const device of this.devices) {\n                device.stop();\n            }\n            if (this.autoDetector) {\n                this.autoDetector.close();\n            }\n\n            this.log.info('cleaned everything up...');\n            callback();\n        } catch (e) {\n            callback();\n        }\n    }\n\n    /**\n     * Is called if a subscribed state changes\n     */\n    private async onStateChange(id: string, state: ioBroker.State | null | undefined): Promise<void> {\n        if (state) { //ignore delete state\n            // The state was changed\n            this.log.info(`state ${id} changed: ${state.val} (ack = ${state.ack})`);\n\n            //only act if ack = false.\n            if (state.ack === false) {\n                const deviceId = id.split('.')[2]; //0 = adapter, 1 = instance -> 2 = device id.\n                const device = this.devices.find(d => d.id === deviceId);\n                if (device) {\n                    await device.handleStateChange(id, state);\n                } else {\n                    this.log.info(`Unknown device ${deviceId} for ${id}. Can't control anything.`);\n                }\n            }\n        }\n    }\n\n    // If you need to accept messages in your adapter, uncomment the following block and the corresponding line in the constructor.\n    // /**\n    //  * Some message was sent to this instance over message box. Used by email, pushover, text2speech, ...\n    //  * Using this method requires \"common.messagebox\" property to be set to true in io-package.json\n    //  */\n    private async onMessage(obj: ioBroker.Message) : Promise<void> {\n        if (typeof obj === 'object' && obj.message) {\n            switch(obj.command) {\n                case 'discovery': {\n                    // Send response in callback if required\n                    if (obj.callback) {\n                        const devices = [];\n                        for (const key of Object.keys(this.detectedDevices)) {\n                            const device = this.detectedDevices[key];\n                            device.readOnly = true;\n                            devices.push(device);\n                        }\n                        this.sendTo(obj.from, obj.command, devices, obj.callback);\n                    }\n                    break;\n                }\n                case 'getDevices': {\n                    const tableDevices = [];\n                    for (const device of this.devices)  {\n                        const tableDevice = {\n                            name: device.name,\n                            mac: device.mac,\n                            ip: device.ip,\n                            pin: device.pinDecrypted,\n                            pollInterval: device.pollInterval,\n                            enabled: device.enabled\n                        };\n                        tableDevices.push(tableDevice);\n                    }\n                    if (obj.callback) {\n                        this.sendTo(obj.from, obj.command, tableDevices, obj.callback);\n                    }\n                    break;\n                }\n                case 'identifyDevice': {\n                    const params = (obj.message) as Record<string, any>;\n                    if (params && params.ip && params.pin) {\n                        let device = await createFromTable(this, {\n                            ip: params.ip,\n                            pin: params.pin\n                        });\n                        try {\n                            await device.start();\n                            if (device.loggedIn && device.identified) { //will be false if ip wrong or duplicate mac.\n                                const oldDevice = this.devices.find(d => d.mac === device.mac);\n                                if (oldDevice) {\n                                    device.stop();\n                                    device = oldDevice;\n                                } else {\n                                    this.devices.push(device);\n                                }\n                                const sendDevice = {\n                                    mac: device.mac,\n                                    name: device.name,\n                                    ip: device.ip,\n                                    pollInterval: device.pollInterval,\n                                    pin: device.pinDecrypted,\n                                    enabled: device.loggedIn && device.identified\n                                };\n                                if (obj.callback) {\n                                    this.sendTo(obj.from, obj.command, sendDevice, obj.callback);\n                                }\n                            } else {\n                                this.log.info('could not login -> error.');\n                                this.sendTo(obj.from, obj.command, 'ERROR', obj.callback);\n                            }\n                        } catch (e : any) {\n                            this.log.info('could not login device: ' + e.stack);\n                            if (obj.callback) {\n                                this.sendTo(obj.from, obj.command, 'ERROR', obj.callback);\n                            }\n                        }\n                    }\n                    break;\n                }\n                default: {\n                    this.log.debug('Unknown command ' + obj.command);\n                    break;\n                }\n            }\n        }\n    }\n}\n\nif (require.main !== module) {\n    // Export the constructor in compact mode\n    module.exports = (options: Partial<utils.AdapterOptions> | undefined) => new Mydlink(options);\n} else {\n    // otherwise start the instance directly\n    (() => new Mydlink())();\n}"],
  "mappings": ";;;;;;;;;;;;;;;;;;;AAMA,YAAuB;AAGvB,wBAA2B;AAC3B,wBAA6B;AAE7B,2BAAgD;AAKhD,MAAM,gBAAgB,MAAM,QAAQ;AAAA,EA0BzB,YAAY,UAAyC,CAAC,GAAG;AAC5D,UAAM;AAAA,MACF,GAAG;AAAA,MACH,MAAM;AAAA,IACV,CAAC;AAtBL,mBAAyB,CAAC;AAO1B,+BAAyC,CAAC;AAO1C,2BAAwC,CAAC;AAEzC,wBAAyC;AAOrC,SAAK,GAAG,SAAS,KAAK,QAAQ,KAAK,IAAI,CAAC;AACxC,SAAK,GAAG,eAAe,KAAK,cAAc,KAAK,IAAI,CAAC;AACpD,SAAK,GAAG,WAAW,KAAK,UAAU,KAAK,IAAI,CAAC;AAC5C,SAAK,GAAG,UAAU,KAAK,SAAS,KAAK,IAAI,CAAC;AAAA,EAC9C;AAAA,EAMA,MAAM,iBAAiB,QAAgB;AAEnC,WAAO,KAAK;AAGZ,eAAW,MAAM,OAAO,KAAK,KAAK,eAAe,GAAG;AAChD,YAAM,aAAa,KAAK,gBAAgB;AACxC,UAAI,WAAW,QAAQ,OAAO,IAAI;AAC9B,mBAAW,iBAAiB;AAAA,MAChC;AAAA,IACJ;AAEA,QAAI;AACA,YAAM,MAAM,MAAM,KAAK,mBAAmB;AAAA,QACtC,UAAU,KAAK,YAAY,MAAM,OAAO;AAAA,QACxC,QAAQ,KAAK,YAAY,MAAM,OAAO,KAAK;AAAA,MAC/C,CAAC;AACD,UAAI,KAAK;AACL,mBAAW,OAAO,IAAI,MAAM;AACxB,gBAAM,KAAK,eAAe,IAAI,MAAM,GAAG;AAAA,QAC3C;AAAA,MACJ;AAAA,IACJ,SAAS,GAAP;AACE,WAAK,IAAI,MAAM,8BAA8B,OAAO,KAAK,OAAO,EAAE,KAAK;AAAA,IAC3E;AAAA,EACJ;AAAA,EAKA,MAAc,UAAyB;AAInC,UAAM,eAAe,MAAM,KAAK,sBAAsB,eAAe;AACrE,QAAI,cAAc;AACd,mCAAW,UAAU,aAAa,SAAS,aAAa,OAAO,SAAS,iBAAiB;AAAA,IAC7F;AAGA,SAAK,SAAS,mBAAmB,OAAO,IAAI;AAG5C,SAAK,eAAe,IAAI,+BAAa,IAAI;AAGzC,QAAI,oBAAoB;AACxB,UAAM,kBAAkB,MAAM,KAAK,gBAAgB;AACnD,UAAM,qBAAqB,CAAC,EAAE,OAAO,KAAK,OAAO,OAAO;AACxD,SAAK,IAAI,MAAM,2BAA2B,KAAK,UAAU,iBAAiB,MAAM,CAAC,CAAC;AAClF,SAAK,IAAI,MAAM,yBAAyB,KAAK,UAAU,oBAAoB,MAAM,CAAC,CAAC;AACnF,QAAI,mBAAmB;AACvB,eAAW,kBAAkB,iBAAiB;AAC1C,UAAI,QAAQ;AACZ,iBAAW,gBAAgB,KAAK,OAAO,SAA0B;AAC7D,2BAAmB,CAAC,aAAa;AACjC,YAAK,aAAa,OAAO,aAAa,QAAQ,eAAe,OAAO,OAC/D,CAAC,aAAa,OAAO,aAAa,OAAO,eAAe,OAAO,IAAK;AACrE,kBAAQ;AAGR,qBAAW,OAAO,OAAO,KAAK,YAAY,GAAG;AACzC,2BAAe,OAAO,OAAO,aAAa;AAAA,UAC9C;AACA,yBAAe,OAAO,kBAAkB,CAAC,aAAa;AAEtD,6BAAmB,OAAO,mBAAmB,QAAQ,YAAY,GAAG,CAAC;AACrE;AAAA,QACJ;AAAA,MACJ;AACA,YAAM,SAAS,UAAM,uCAAiB,MAAM,cAAc;AAC1D,YAAM,OAAO,mBAAmB;AAChC,UAAI,eAAe,OAAO,iBAAiB;AACvC,2BAAmB;AAAA,MACvB;AACA,UAAI,OAAO;AACP,4BAAoB,MAAM,OAAO,MAAM,KAAK;AAE5C,aAAK,QAAQ,KAAK,MAAM;AAAA,MAC5B,OAAO;AACH,aAAK,IAAI,MAAM,cAAc,OAAO,IAAI;AACxC,cAAM,KAAK,iBAAiB,MAAM;AAAA,MACtC;AAAA,IACJ;AAGA,eAAW,gBAAgB,oBAAoB;AAC3C,YAAM,SAAS,UAAM,sCAAgB,MAAM,cAAc,CAAC,aAAa,eAAe;AACtF,WAAK,IAAI,MAAM,YAAY,OAAO,OAAO,kDAAkD;AAC3F,YAAM,YAAY,KAAK,QAAQ,KAAK,OAAK,EAAE,QAAQ,OAAO,GAAG;AAC7D,UAAI,WAAW;AACX,aAAK,IAAI,KAAK,yBAAyB,OAAO,MAAM,2EAA2E,OAAO,OAAO,UAAU,aAAa,IAAI;AACxK,2BAAmB;AAAA,MACvB,OAAO;AAEH,cAAM,OAAO,mBAAmB;AAEhC,4BAAoB,MAAM,OAAO,MAAM,KAAK;AAE5C,cAAM,OAAO,mBAAmB;AAEhC,aAAK,QAAQ,KAAK,MAAM;AAAA,MAC5B;AAAA,IACJ;AAGA,QAAI,kBAAkB;AAClB,YAAM,UAAU,CAAC;AACjB,iBAAW,UAAU,KAAK,SAAS;AAC/B,cAAM,eAAe;AAAA,UACjB,IAAI,OAAO;AAAA,UACX,KAAK,OAAO;AAAA,UACZ,KAAK,OAAO;AAAA,UACZ,cAAc,OAAO;AAAA,UACrB,SAAS,OAAO;AAAA,UAChB,MAAM,OAAO;AAAA,UACb,OAAO,OAAO;AAAA,UACd,cAAc,OAAO;AAAA,QACzB;AACA,gBAAQ,KAAK,YAAY;AAAA,MAC7B;AACA,YAAM,KAAK,yBAAyB,oBAAoB,KAAK,WAAW;AAAA,QACpE,QAAQ;AAAA,UACJ;AAAA,QACJ;AAAA,MACJ,CAAC;AAAA,IACL;AAEA,UAAM,KAAK,qBAAqB,mBAAmB,CAAC,mBAAmB,IAAI;AAAA,EAC/E;AAAA,EAKQ,SAAS,UAA4B;AACzC,QAAI;AACA,WAAK,IAAI,MAAM,cAAc;AAC7B,iBAAW,UAAU,KAAK,SAAS;AAC/B,eAAO,KAAK;AAAA,MAChB;AACA,UAAI,KAAK,cAAc;AACnB,aAAK,aAAa,MAAM;AAAA,MAC5B;AAEA,WAAK,IAAI,KAAK,0BAA0B;AACxC,eAAS;AAAA,IACb,SAAS,GAAP;AACE,eAAS;AAAA,IACb;AAAA,EACJ;AAAA,EAKA,MAAc,cAAc,IAAY,OAAyD;AAC7F,QAAI,OAAO;AAEP,WAAK,IAAI,KAAK,SAAS,eAAe,MAAM,cAAc,MAAM,MAAM;AAGtE,UAAI,MAAM,QAAQ,OAAO;AACrB,cAAM,WAAW,GAAG,MAAM,GAAG,EAAE;AAC/B,cAAM,SAAS,KAAK,QAAQ,KAAK,OAAK,EAAE,OAAO,QAAQ;AACvD,YAAI,QAAQ;AACR,gBAAM,OAAO,kBAAkB,IAAI,KAAK;AAAA,QAC5C,OAAO;AACH,eAAK,IAAI,KAAK,kBAAkB,gBAAgB,6BAA6B;AAAA,QACjF;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AAAA,EAOA,MAAc,UAAU,KAAuC;AAC3D,QAAI,OAAO,QAAQ,YAAY,IAAI,SAAS;AACxC,cAAO,IAAI,SAAS;AAAA,QAChB,KAAK,aAAa;AAEd,cAAI,IAAI,UAAU;AACd,kBAAM,UAAU,CAAC;AACjB,uBAAW,OAAO,OAAO,KAAK,KAAK,eAAe,GAAG;AACjD,oBAAM,SAAS,KAAK,gBAAgB;AACpC,qBAAO,WAAW;AAClB,sBAAQ,KAAK,MAAM;AAAA,YACvB;AACA,iBAAK,OAAO,IAAI,MAAM,IAAI,SAAS,SAAS,IAAI,QAAQ;AAAA,UAC5D;AACA;AAAA,QACJ;AAAA,QACA,KAAK,cAAc;AACf,gBAAM,eAAe,CAAC;AACtB,qBAAW,UAAU,KAAK,SAAU;AAChC,kBAAM,cAAc;AAAA,cAChB,MAAM,OAAO;AAAA,cACb,KAAK,OAAO;AAAA,cACZ,IAAI,OAAO;AAAA,cACX,KAAK,OAAO;AAAA,cACZ,cAAc,OAAO;AAAA,cACrB,SAAS,OAAO;AAAA,YACpB;AACA,yBAAa,KAAK,WAAW;AAAA,UACjC;AACA,cAAI,IAAI,UAAU;AACd,iBAAK,OAAO,IAAI,MAAM,IAAI,SAAS,cAAc,IAAI,QAAQ;AAAA,UACjE;AACA;AAAA,QACJ;AAAA,QACA,KAAK,kBAAkB;AACnB,gBAAM,SAAU,IAAI;AACpB,cAAI,UAAU,OAAO,MAAM,OAAO,KAAK;AACnC,gBAAI,SAAS,UAAM,sCAAgB,MAAM;AAAA,cACrC,IAAI,OAAO;AAAA,cACX,KAAK,OAAO;AAAA,YAChB,CAAC;AACD,gBAAI;AACA,oBAAM,OAAO,MAAM;AACnB,kBAAI,OAAO,YAAY,OAAO,YAAY;AACtC,sBAAM,YAAY,KAAK,QAAQ,KAAK,OAAK,EAAE,QAAQ,OAAO,GAAG;AAC7D,oBAAI,WAAW;AACX,yBAAO,KAAK;AACZ,2BAAS;AAAA,gBACb,OAAO;AACH,uBAAK,QAAQ,KAAK,MAAM;AAAA,gBAC5B;AACA,sBAAM,aAAa;AAAA,kBACf,KAAK,OAAO;AAAA,kBACZ,MAAM,OAAO;AAAA,kBACb,IAAI,OAAO;AAAA,kBACX,cAAc,OAAO;AAAA,kBACrB,KAAK,OAAO;AAAA,kBACZ,SAAS,OAAO,YAAY,OAAO;AAAA,gBACvC;AACA,oBAAI,IAAI,UAAU;AACd,uBAAK,OAAO,IAAI,MAAM,IAAI,SAAS,YAAY,IAAI,QAAQ;AAAA,gBAC/D;AAAA,cACJ,OAAO;AACH,qBAAK,IAAI,KAAK,2BAA2B;AACzC,qBAAK,OAAO,IAAI,MAAM,IAAI,SAAS,SAAS,IAAI,QAAQ;AAAA,cAC5D;AAAA,YACJ,SAAS,GAAP;AACE,mBAAK,IAAI,KAAK,6BAA6B,EAAE,KAAK;AAClD,kBAAI,IAAI,UAAU;AACd,qBAAK,OAAO,IAAI,MAAM,IAAI,SAAS,SAAS,IAAI,QAAQ;AAAA,cAC5D;AAAA,YACJ;AAAA,UACJ;AACA;AAAA,QACJ;AAAA,QACA,SAAS;AACL,eAAK,IAAI,MAAM,qBAAqB,IAAI,OAAO;AAC/C;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AACJ;AAEA,IAAI,QAAQ,SAAS,QAAQ;AAEzB,SAAO,UAAU,CAAC,YAAuD,IAAI,QAAQ,OAAO;AAChG,OAAO;AAEH,GAAC,MAAM,IAAI,QAAQ,GAAG;AAC1B;",
  "names": []
}
