{
  "version": 3,
  "sources": ["../../src/lib/WebSocketDevice.ts"],
  "sourcesContent": ["import {Device, processNetworkError, WrongMacError} from './Device';\nimport {Suffixes} from './suffixes';\nimport {Mydlink} from './mydlink';\nimport {default as axios} from 'axios';\nimport {KnownDevices} from './KnownDevices';\nimport WebSocketClient from 'dlink_websocketclient';\n\nexport class WebSocketDevice extends Device {\n    client: WebSocketClient;\n\n    numSockets = 1;\n\n    constructor(adapter: Mydlink, ip: string, pin: string, pinEncrypted: boolean) {\n        super(adapter, ip, pin, pinEncrypted);\n        this.isWebsocket = true;\n\n        this.client = new WebSocketClient({\n            ip: this.ip,\n            pin: this.pinDecrypted,\n            keepAlive: 5,\n            useTelnetForToken: this.pinDecrypted.toUpperCase() === 'TELNET',\n            log: console.debug\n        });\n    }\n\n    /**\n     * Creates objects for the device.\n     */\n    async createObjects() : Promise<void> {\n        await super.createObjects();\n        if (this.numSockets > 1) {\n            //create state for each socket.\n            for (let index = 1; index <= this.numSockets; index += 1) {\n                const id = this.id + Suffixes.state + '_' + index;\n                await this.adapter.setObjectNotExistsAsync(id, {\n                    type: 'state',\n                    common: {\n                        name: 'Socket ' + index,\n                        type: 'boolean',\n                        role: 'switch',\n                        read: true,\n                        write: true\n                    },\n                    native: { index: index }\n                });\n                await this.adapter.subscribeStatesAsync(id);\n            }\n        } else {\n            //create state object, for plug this is writable for sensor not.\n            await this.adapter.setObjectNotExistsAsync(this.id + Suffixes.state, {\n                type: 'state',\n                common: {\n                    name: 'state of plug',\n                    type: 'boolean',\n                    role: 'switch',\n                    read: true,\n                    write: true\n                },\n                native: {}\n            });\n            await this.adapter.subscribeStatesAsync(this.id + Suffixes.state);\n        }\n    }\n\n    stop() : void {\n        super.stop();\n        if (this.client && typeof this.client.removeAllListeners === 'function') {\n            this.client.removeAllListeners('switch');\n            this.client.removeAllListeners('error');\n            this.client.removeAllListeners('close');\n        }\n    }\n\n    /**\n     * Do polling here.\n     * @returns {Promise<void>}\n     */\n    async onInterval() : Promise<void> {\n        await super.onInterval();\n        // if not ready -> communication did fail, will be retried on next poll.\n        if (this.ready) {\n            if (this.numSockets > 1) {\n                const states = await this.client.state(-1) as Array<boolean>; //get all socket states.\n                for (let index = 1; index <= this.numSockets; index += 1) {\n                    const id = this.id + Suffixes.state + '_' + index;\n                    const val = states[index - 1];\n                    await this.adapter.setStateChangedAsync(id, val, true);\n                }\n            } else {\n                const val = await this.client.state(0) as boolean;\n                await this.adapter.setStateChangedAsync(this.id + Suffixes.state, val, true);\n            }\n        }\n    }\n\n    /**\n     * Error handler for event base client.\n     */\n    async onError(code? : number, err? : Error) : Promise<void> {\n        await this.adapter.setStateAsync(this.id + Suffixes.unreachable, true, true);\n        if (code || err) {\n            this.adapter.log.debug(`${this.name}: Socket error: ${code} - ${(err ? err.stack : err)}`);\n        } else {\n            this.adapter.log.debug(this.name + ': Socket closed.');\n        }\n        this.stop();\n        this.ready = false;\n        //abuse unused intervalHandle here.\n        if (this.intervalHandle) {\n            this.adapter.clearTimeout(this.intervalHandle);\n        }\n        this.intervalHandle = this.adapter.setTimeout(() => {\n            this.start();\n        }, 10000);\n    }\n\n    /**\n     * starting communication with device from config.\n     * @returns {Promise<boolean>}\n     */\n    async start() : Promise<boolean> {\n        const result = super.start();\n        //event listener:\n        this.client.on('switched', (val : boolean, socket : number) => {\n            this.adapter.log.debug(`Event from device ${socket} now ${val}`);\n            if (this.numSockets > 1) {\n                this.adapter.setStateAsync(this.id + Suffixes.state + '_' + (socket + 1), val, true);\n            } else {\n                this.adapter.setStateAsync(this.id + Suffixes.state, val, true);\n            }\n        });\n        //error handling:\n        this.client.on('error', (code : number, error : Error) => this.onError(code, error));\n        this.client.on('close', () => this.onError());\n        this.client.on('message', (message : string) => this.adapter.log.debug(`${this.name} got message: ${message}`));\n        await this.adapter.setStateAsync(this.id + Suffixes.unreachable, false, true);\n        this.ready = true;\n        this.adapter.log.debug('Setup device event listener.');\n\n        return result;\n    }\n\n    /**\n     * process a state change. Device will just try to switch plug. Childs will have to overwrite this behaviour.\n     * @param id\n     * @param state\n     */\n    async handleStateChange(id : string, state : ioBroker.State) : Promise<void> {\n        if (typeof state.val === 'boolean') {\n            if (!this.loggedIn) {\n                await this.login();\n            }\n\n            let socket = 0;\n            if (this.numSockets > 1) {\n                socket = Number(id.substring(id.lastIndexOf('_') + 1)) - 1; //convert to 0 based index here.\n            }\n            try {\n                const newVal = await this.client.switch(state.val, socket);\n                this.adapter.log.debug(`Switched Socket ${socket} of ${this.name} ${state.val ? 'on' : 'off'}.`);\n                await this.adapter.setStateAsync(id, newVal, true);\n            } catch(e: any) {\n                const code = processNetworkError(e);\n                if (code === 403) {\n                    this.loggedIn = false; //login next polling.\n                }\n                this.adapter.log.error('Error while switching device ' + this.name + ': ' + code + ' - ' + e.stack);\n            }\n        } else {\n            this.adapter.log.warn('Wrong state type. Only boolean accepted for switch.');\n        }\n    }\n\n    async identify() : Promise<boolean> {\n        const id = this.client.getDeviceId();\n        const mac = id.match(/.{2}/g)!.join(':').toUpperCase(); //add back the :.\n\n        if (this.mac && this.mac !== mac) {\n            throw new WrongMacError(`${this.name} reported mac ${mac}, expected ${this.mac}, probably ip ${this.ip} wrong and talking to wrong device?`);\n        }\n        this.mac = mac;\n\n        //get model from webserver / wifi-ssid:\n        const url = `http://${this.ip}/login?username=Admin&password=${this.pinDecrypted}`;\n        const result = await axios.get(url);\n        if (result.status === 200) {\n            const startPos = result.data.indexOf('SSID: ') + 6;\n            const model = result.data.substring(startPos, startPos + 8);\n            if (!model) {\n                this.adapter.log.warn(`${this.name} identify responded with unknown result, please report: ${result.data}`);\n            }\n            this.adapter.log.debug('Got model ' + model + ' during identification of ' + this.name);\n            if (model !== this.model) {\n                this.adapter.log.debug('Model updated from ' + (this.model || 'unknown') + ' to ' + model);\n                this.model = model;\n                //store new model in device object:\n                await this.createDeviceObject();\n            }\n        }\n\n        if (!KnownDevices[this.model]) {\n            //unknown device -> report to sentry.\n            const info = 'UNKNOWN WEBSOCKET DEVICE: ' + this.model;\n            await this.sendModelInfoToSentry({info});\n        }\n\n        //get current state:\n        if (this.numSockets > 1) {\n            const states = await this.client.state(-1) as Array<boolean>; //get all states.\n            for (let index = 1; index <= this.numSockets; index += 1) {\n                await this.adapter.setStateChangedAsync(this.id + Suffixes.state + '_' + index, states[index -1], true);\n            }\n        } else {\n            const state = await this.client.state() as boolean;\n            await this.adapter.setStateChangedAsync(this.id + Suffixes.state, state, true);\n        }\n\n        return super.identify();\n    }\n}\n"],
  "mappings": "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",
  "names": ["WebSocketClient", "axios"]
}
