{
  "version": 3,
  "sources": ["../../src/lib/WebSocketDevice.ts"],
  "sourcesContent": ["import { WebSocketClient } from 'dlink_websocketclient';\nimport { Device } from './Device';\nimport {Suffixes} from './suffixes';\n\nexport class WebSocketDevice extends Device {\n    client: WebSocketClient;\n\n    numSockets = 1;\n\n    constructor(adapter: ioBroker.Adapter, ip: string, pin: string, pinEncrypted: boolean) {\n        super(adapter, ip, pin, pinEncrypted);\n        this.isWebsocket = true;\n\n        this.client = new WebSocketClient({\n            ip: this.ip,\n            pin: this.pinDecrypted,\n            keepAlive: 5,\n            useTelnetForToken: this.pinDecrypted.toUpperCase() === 'TELNET',\n            log: console.debug\n        });\n    }\n\n    stop() : void {\n        super.stop();\n        if (this.client && typeof this.client.removeAllListeners === 'function') {\n            this.client.removeAllListeners('switch');\n            this.client.removeAllListeners('error');\n            this.client.removeAllListeners('close');\n        }\n    }\n\n    /**\n     * Do polling here.\n     * @returns {Promise<void>}\n     */\n    async onInterval() : Promise<void> {\n        await super.onInterval();\n        // if not ready -> communication did fail, will be retried on next poll.\n        if (this.ready) {\n            if (this.numSockets > 1) {\n                const states = await this.client.state(-1) as Array<boolean>; //get all socket states.\n                for (let index = 1; index <= this.numSockets; index += 1) {\n                    const id = this.id + Suffixes.state + '_' + index;\n                    const val = states[index - 1];\n                    await this.adapter.setStateChangedAsync(id, val, true);\n                }\n            } else {\n                const val = await this.client.state(0) as boolean;\n                await this.adapter.setStateChangedAsync(this.id + Suffixes.state, val, true);\n            }\n        }\n    }\n\n    /**\n     * Error handler for event base client.\n     */\n    async onError(code? : number, err? : Error) : Promise<void> {\n        await this.adapter.setStateAsync(this.id + Suffixes.unreachable, true, true);\n        if (code || err) {\n            this.adapter.log.debug(`${this.name}: Socket error: ${code} - ${(err ? err.stack : err)}`);\n        } else {\n            this.adapter.log.debug(this.name + ': Socket closed.');\n        }\n        this.stop();\n        this.ready = false;\n        //abuse unused intervalHandle here.\n        if (this.intervalHandle) {\n            clearTimeout(this.intervalHandle);\n        }\n        this.intervalHandle = setTimeout(() => {\n            this.start();\n        }, 10000);\n    }\n\n    /**\n     * starting communication with device from config.\n     * @returns {Promise<boolean>}\n     */\n    async start() : Promise<boolean> {\n        const result = super.start();\n        //event listener:\n        this.client.on('switched', (val, socket) => {\n            this.adapter.log.debug(`Event from device ${socket} now ${val}`);\n            if (this.numSockets > 1) {\n                this.adapter.setStateAsync(this.id + Suffixes.state + '_' + (socket + 1), val, true);\n            } else {\n                this.adapter.setStateAsync(this.id + Suffixes.state, val, true);\n            }\n        });\n        //error handling:\n        this.client.on('error', (code, error) => this.onError(code, error));\n        this.client.on('close', () => this.onError());\n        this.client.on('message', (message) => this.adapter.log.debug(`${this.name} got message: ${message}`));\n        await this.adapter.setStateAsync(this.id + Suffixes.unreachable, false, true);\n        this.ready = true;\n        this.adapter.log.debug('Setup device event listener.');\n\n        return result;\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
