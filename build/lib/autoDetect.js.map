{
  "version": 3,
  "sources": ["../../src/lib/autoDetect.ts"],
  "sourcesContent": ["import { Mydlink } from '../main';\nimport { Mdns } from 'mdns-discovery';\n\nimport { WebSocketDevice } from './WebSocketDevice';\n\nexport class AutoDetector {\n    mdns: Mdns;\n\n    adapter: Mydlink;\n\n    detectedDevices: Record<string, any> = {};\n\n    debug = false;\n\n    logDebug(message: string) : void {\n        if (this.debug) {\n            this.adapter.log.debug(message);\n        }\n    }\n\n    async onDetection(entry : { ip: string, type: string, name: string, mac: string | undefined, PTR: any | undefined, TXT : any | undefined}) : Promise<void> {\n        //format of data: length-byte + text + length-byte + text + length-byte + text ...\n        function extractStringsFromBuffer(buffer : Buffer) : string[] {\n            let index = 0;\n            const strings = [];\n            while(index < buffer.length) {\n                const length = buffer.readInt8(index);\n                index += 1;\n                strings.push(buffer.subarray(index, index + length).toString());\n                index += length;\n            }\n            return strings;\n        }\n\n        //somehow starts to detect fritzbox later on??\n        if (entry.name !== '_dhnap._tcp.local' && entry.name !== '_dcp._tcp.local') {\n            //this.log.debug('Ignoring false detection? -> ' + entry.ip + ' - ' + entry.name);\n            return;\n        }\n        if (entry.name === '_dcp._tcp.local') {\n            this.logDebug('Maybe detected websocket device');\n            console.log(entry);\n            //get model:\n            let model;\n            if (entry.PTR && entry.PTR.data) {\n                model = entry.PTR.data.substring(0, 8);\n            }\n\n            //somehow I get records for devices from wrong IP. or they report devices, they detect under their IP?? not sure...\n            //let's connect here and get the MAC -> so we can securely identify the device.\n            //then decide if it is a new one (update & present in UI) or an old one (ignore for now).\n            const newDevice = new WebSocketDevice(this.adapter, entry.ip, 'INVALID', false);\n            newDevice.model = model;\n\n            try {\n                await newDevice.client.login();\n                newDevice.id = newDevice.client.getDeviceId().toUpperCase();\n                if (newDevice.id) {\n                    newDevice.mac = newDevice.id.match(/.{2}/g)!.join(':');\n                    this.logDebug(`Got websocket device ${model} on ${newDevice.ip}`);\n                }\n            } catch (e: any) {\n                this.logDebug('Could not identify websocket device: ' + e.stack);\n            } finally {\n                newDevice.stop();\n            }\n\n            //now use mac to check if we already now that device:\n            const device = this.adapter.devices.find(device => device.mac === entry.mac);\n            if (device) {\n                this.logDebug(`Device was already present as ${device.model} on ${device.ip}`);\n                if (device.ip === newDevice.ip && device.model !== newDevice.model) {\n                    this.logDebug(`Model still differs? ${device.model} != ${newDevice.model}`);\n                    if (model && device.isWebsocket) {\n                        this.logDebug('Updated model to ' + model);\n                        device.model = model;\n                        await device.createDeviceObject(); //store new model in config.\n                    }\n                }\n            } else { //not known yet, add to detected devices:\n                this.detectedDevices[entry.ip] = {\n                    ip: newDevice.ip,\n                    name: entry.name,\n                    type: model,\n                    mac: newDevice.mac,\n                    mydlink: true,\n                    useWebSocket: true,\n                    alreadyPresent: !!device\n                };\n            }\n        }\n\n        //this.log.debug('Got discovery: ' + JSON.stringify(entry, null, 2));\n        if (entry.TXT && entry.TXT.data) {\n            //build detected device and fill it:\n            let device = this.detectedDevices[entry.ip];\n            if (!device) {\n                device = {\n                    ip: entry.ip,\n                    name: entry.name\n                };\n            }\n\n            //parse buffer:\n            const keyValuePairs = extractStringsFromBuffer(entry.TXT.data);\n            for (const pair of keyValuePairs) {\n                const [ key, value ] = pair.split('=');\n                switch(key.toLowerCase()) {\n                    //extract mac from buffer:\n                    case 'mac': {\n                        device.mac = value.toUpperCase();\n                        break;\n                    }\n                    //extract model number from buffer:\n                    case 'model_number': {\n                        device.type = value;\n                        break;\n                    }\n                    //if mydlink=true -> we should look at that device! :)\n                    case 'mydlink': {\n                        if (value === 'true') {\n                            device.mydlink = true; //ok, great :-)\n                        }\n                    }\n                }\n            }\n\n            if (device.mydlink) {\n                this.detectedDevices[device.ip] = device;\n                const oldDevice = this.adapter.devices.find(d => d.mac === device.mac);\n                if (oldDevice) {\n                    //update model, if differs.\n                    if (oldDevice.model !== device.type) {\n                        oldDevice.model = device.type;\n                    }\n                    //found device we already know. Let's check ip.\n                    if (device.ip !== oldDevice.ip) {\n                        oldDevice.ip = device.ip;\n                        await oldDevice.createDeviceObject(); //store IP in config.\n                        await oldDevice.start();\n                    }\n                    device.alreadyPresent = true;\n                }\n                this.logDebug('Detected Device now is: ' + JSON.stringify(device, null, 2));\n            }\n        }\n    }\n\n    close () {\n        if (this.mdns && typeof this.mdns.close === 'function') {\n            this.mdns.close();\n        }\n    }\n\n    constructor (adapter : Mydlink) {\n        this.adapter = adapter;\n        this.mdns = new Mdns({\n            timeout: 0, //0 == stay active??\n            name: [ '_dhnap._tcp.local', '_dcp._tcp.local' ],\n            find: '*',\n            broadcast: false\n        });\n\n\n        this.logDebug('Auto detection started');\n        if (this.mdns !== undefined) {\n            this.mdns.on('entry', this.onDetection.bind(this));\n            this.mdns.run(() => adapter.log.info('Discovery done'));\n        }\n    }\n}\n"],
  "mappings": "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",
  "names": ["device"]
}
