{
  "version": 3,
  "sources": ["../../src/lib/Device.ts"],
  "sourcesContent": ["import { Client } from './Clients';\nimport { DeviceInfo } from './DeviceInfo';\nimport { Suffixes } from './suffixes';\nimport {Mydlink} from '../main';\n\n/**\n * Get code from network error.\n * @param {Record<string, any>} e\n * @returns {number|string}\n */\nexport function processNetworkError(e: Record<string, any>) {\n    if (e.response) {\n        // The request was made and the server responded with a status code\n        // that falls out of the range of 2xx\n        //See if we are logged out -> login again on next poll.\n        //otherwise ignore and try again later?\n        return e.response.status;\n    } else if (e.request) {\n        // The request was made but no response was received\n        // `error.request` is an instance of XMLHttpRequest in the browser and an instance of\n        // http.ClientRequest in node.js\n        //probably ECONNRESET or Timeout -> e.code should be set.\n        return e.code;\n    } else {\n        //something else...?\n        return e.code;\n    }\n}\n\nexport abstract class Device extends  DeviceInfo {\n    readonly adapter: Mydlink;\n    abstract client: Client;\n    constructor (adapter : Mydlink, ip : string, pin: string, pinEncrypted: boolean) {\n        super(ip, pin, pinEncrypted);\n        this.adapter = adapter;\n    }\n\n    /**\n     * Create DeviceInfo from ioBroker object, old createDeviceFromConfig\n     * @param adapter ioBroker Adapter\n     * @param configDevice ioBroker device object\n     * @returns Device\n     */\n    static createFromObject<Type extends Device>(this: { new(adapter : ioBroker.Adapter, ip : string, pin: string, pinEncrypted: boolean): Type },\n        adapter : ioBroker.Adapter, configDevice: ioBroker.DeviceObject) : Type {\n\n        const native = configDevice.native;\n        const pinEncrypted = (native.mac && !native.pinNotEncrypted);\n        const device = new this(adapter, native.ip, native.pin, pinEncrypted);\n        device.pollInterval = native.pollInterval;\n        device.mac = native.mac ? native.mac.toUpperCase() : '';\n        device.id = configDevice._id.split('.')[2];\n        device.name = native.name;\n        device.model = native.model || '';\n        device.enabled = native.enabled;\n        //TODO: native has \"useWebsocket\" -> how to handle this here? Hm..\n        device.isWebsocket = native.useWebsocket;\n        return device;\n    }\n\n    /**\n     * Creates DeviceInfo from configuration-Table object.\n     * @param adapter ioBroker Adapter\n     * @param tableDevice\n     * @param doDecrypt\n     * @returns Device\n     */\n    static createFromTable<Type extends Device>(this: { new(adapter : ioBroker.Adapter, ip : string, pin: string, pinEncrypted: boolean): Type },\n        adapter : ioBroker.Adapter, tableDevice: { pin: string, ip: string, pollInterval: undefined | number | string, mac: undefined | string, name: string, enabled: boolean}, doDecrypt = false) : Type {\n        const pinEncrypted = (doDecrypt && Boolean(tableDevice.mac));\n        const device = new this(adapter, tableDevice.ip, tableDevice.pin, pinEncrypted);\n        device.pollInterval = tableDevice.pollInterval !== undefined && isFinite(Number(tableDevice.pollInterval)) && tableDevice.pollInterval >= 0 ? Number(tableDevice.pollInterval) : 30000;\n        device.mac = tableDevice.mac ? tableDevice.mac.toUpperCase() : '';\n        tableDevice.mac ? device.idFromMac() : '';\n        device.name = tableDevice.name;\n        device.enabled = tableDevice.enabled;\n        return device;\n    }\n\n    async createDeviceObject () : Promise<void> {\n        //do something here.\n        if (!this.id) {\n            if (!this.mac) {\n                this.adapter.log.warn('Could not create device ' + this.name + ' without MAC. Please check config or if device is online.');\n                return;\n            }\n        }\n\n        //also set the native part of the device:\n        await this.adapter.extendObjectAsync(this.id, {\n            type: 'device',\n            common: {\n                name: this.name,\n                statusStates: {\n                    onlineId: `${this.adapter.namespace}.${this.id}.${Suffixes.reachable}`\n                }\n            } as Partial<ioBroker.DeviceCommon>,\n            native: {\n                ip: this.ip,\n                mac: this.mac,\n                pin: this.pinEncrypted,\n                pollInterval: this.pollInterval,\n                enabled: this.enabled,\n                name: this.name,\n                model: this.model,\n                useWebSocket: this.isWebsocket\n            }\n        });\n    }\n\n    /**\n     * Creates objects for the device.\n     */\n    async createObjects() {\n        //enabled indicator:\n        await this.adapter.setObjectNotExistsAsync(this.id + Suffixes.enabled, {\n            type: 'state',\n            common: {\n                name: 'enabled',\n                type: 'boolean',\n                role: 'indicator',\n                read: true,\n                write: false\n            },\n            native: {}\n        });\n\n        //have ready indicator:\n        await this.adapter.setObjectNotExistsAsync(this.id + Suffixes.unreachable, {\n            type: 'state',\n            common: {\n                name: 'unreach',\n                type: 'boolean',\n                role: 'indicator.maintenance.unreach',\n                read: true,\n                write: false\n            },\n            native: {}\n        });\n\n        //have ready indicator:\n        await this.adapter.setObjectNotExistsAsync(this.id + Suffixes.reachable, {\n            type: 'state',\n            common: {\n                name: 'device is reachable',\n                type: 'boolean',\n                role: 'indicator.reachable',\n                read: true,\n                write: false\n            },\n            native: {}\n        });\n    }\n\n    stop() {\n        if (this.intervalHandle) {\n            clearInterval(this.intervalHandle);\n        }\n        if (this.client && typeof this.client.disconnect === 'function') {\n            this.client.disconnect();\n        }\n        this.ready = false;\n        this.loggedIn = false;\n    }\n\n    async login() {\n        //TODO!\n        await this.adapter.setStateAsync(this.id + Suffixes.reachable, this.ready, true);\n        await this.adapter.setStateAsync(this.id + Suffixes.unreachable, !this.ready, true);\n    }\n\n    async identify() {\n        //TODO!\n    }\n\n    async handleNetworkError(e: any) {\n        const code = processNetworkError(e);\n        if (code === 403 || this.ready) {\n            this.loggedIn = false; //login next polling.\n        }\n        this.adapter.log.debug('Error during communication ' + this.name + ': ' + code + ' - ' + e.stack + ' - ' + e.body);\n        this.ready = false;\n        await this.adapter.setStateChangedAsync(this.id + Suffixes.unreachable, true, true);\n        await this.adapter.setStateChangedAsync(this.id + Suffixes.reachable, false, true);\n\n        let connected = false;\n        this.adapter.devices.forEach((device) => { connected = connected || device.ready; }); //turn green if at least one device is ready = reachable.\n        await this.adapter.setStateChangedAsync('info.connection', connected, true);\n    }\n\n    /**\n     * Do polling here.\n     * @returns {Promise<void>}\n     */\n    async onInterval() : Promise<void> {\n        //this.log.debug('Polling ' + this.name);\n        try {\n            if (!this.loggedIn) {\n                await this.login();\n            }\n            if (this.loggedIn && !this.identified) {\n                await this.identify();\n            }\n            if (this.loggedIn && this.identified) {\n                this.ready = this.client.isDeviceReady();\n                await this.adapter.setStateChangedAsync(this.id + Suffixes.unreachable, !this.ready, true);\n                await this.adapter.setStateAsync(this.id + Suffixes.reachable, this.ready, true);\n\n                //prevent more interaction with device and reset connection.\n                if (this.ready) {\n                    //signal that we could at least reach one device:\n                    await this.adapter.setStateChangedAsync('info.connection', true, true);\n                }\n            }\n        } catch (e: any) {\n            await this.handleNetworkError(e);\n        }\n\n        if (this.pollInterval > 0) { //only start timeout again, if set in settings.\n            this.intervalHandle = setTimeout(() => this.onInterval,\n                this.pollInterval);\n        }\n    }\n\n    /**\n     * starting communication with device from config.\n     * @returns {Promise<boolean>}\n     */\n    async start() {\n        //if device was already started -> stop it.\n        //(use case: ip did change or settings did change)\n        this.stop();\n\n        //interrogate enabled devices\n        //this will get MAC for manually configured devices.\n        if (this.enabled) {\n            //login:\n            await this.login();\n\n            if (this.loggedIn) {\n                try {\n                    await this.identify();\n                } catch (e: any) {\n                    this.adapter.log.error(this.name + ' could not get settings: ' + e.stack);\n                }\n            }\n        }\n\n        //transfer enabled flag to object:\n        await this.adapter.setStateAsync(this.id + Suffixes.enabled, {val: this.enabled, ack: true});\n\n        //start polling if device is enabled (do this after all is setup).\n        let result = false;\n        if (this.enabled) {\n            //some devices, for example W245, don't push.. so poll websocket also.\n            let interval = this.pollInterval;\n            if (interval !== undefined && !Number.isNaN(interval) && interval > 0) {\n                this.adapter.log.debug('Start polling for ' + this.name + ' with interval ' + interval);\n                result = true; //only use yellow/green states if polling at least one device.\n                if (interval < 500) {\n                    this.adapter.log.warn('Increasing poll rate to twice per second. Please check device config.');\n                    interval = 500; //polling twice every second should be enough, right?\n                }\n                if (interval >= 2147483647) {\n                    interval = 2147483646;\n                    this.adapter.log.warn('Poll rate was too high, reduced to prevent issues.');\n                }\n                this.pollInterval = interval;\n                this.intervalHandle = setTimeout(() => this.onInterval,\n                    this.pollInterval);\n            } else {\n                this.pollInterval = 0;\n                this.adapter.log.debug('Polling of ' + this.name + ' disabled, interval was ' + interval + ' (0 means disabled)');\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * process a state change. Device will just try to switch plug. Childs will have to overwrite this behaviour.\n     * @param id\n     * @param state\n     */\n    async handleStateChange(id : string, state : ioBroker.State) {\n        if (this.loggedIn) {\n            await this.login();\n        }\n\n    }\n\n}\n\n"],
  "mappings": "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",
  "names": []
}
