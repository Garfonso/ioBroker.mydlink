{
  "version": 3,
  "sources": ["../../src/lib/Device.ts"],
  "sourcesContent": ["import { Client } from './Clients';\nimport { DeviceInfo } from './DeviceInfo';\nimport { Suffixes } from './suffixes';\nimport {Mydlink} from './mydlink';\nimport {KnownDevices} from './KnownDevices';\nimport {TableDevice} from './TableDevice';\nimport {SoapDevice} from './soapDevice';\nimport {WebSocketDevice} from './WebSocketDevice';\n\nexport interface DeviceConstructor<T> {\n    new (adapter: Mydlink, ip: string, pin: string, pinEncrypted: boolean): T;\n}\n\nexport class WrongMacError extends Error {\n    name = 'WRONGMAC';\n    constructor(message: string) {\n        super(message);\n    }\n}\n\nexport class WrongModelError extends Error {\n    name = 'WRONGMODEL';\n    constructor(message: string) {\n        super(message);\n    }\n}\n\n/**\n * Get code from network error.\n * @param {Record<string, any>} e\n * @returns {number|string}\n */\nexport function processNetworkError(e: Record<string, any>) {\n    if (e.response) {\n        // The request was made and the server responded with a status code\n        // that falls out of the range of 2xx\n        //See if we are logged out -> login again on next poll.\n        //otherwise ignore and try again later?\n        return e.response.status;\n    } else if (e.request) {\n        // The request was made but no response was received\n        // `error.request` is an instance of XMLHttpRequest in the browser and an instance of\n        // http.ClientRequest in node.js\n        //probably ECONNRESET or Timeout -> e.code should be set.\n        return e.code;\n    } else {\n        //something else...?\n        return e.code;\n    }\n}\n\nfunction deviceObjetToTableDevice(configDevice: ioBroker.DeviceObject) : TableDevice {\n    return {\n        name: configDevice.native.name,\n        mac: configDevice.native.mac,\n        ip: configDevice.native.ip,\n        pin: configDevice.native.pin,\n        pollInterval: configDevice.native.pollInterval,\n        enabled: configDevice.native.enabled,\n    }\n}\n\nexport abstract class Device extends DeviceInfo {\n    readonly adapter: Mydlink;\n    abstract client: Client;\n    constructor (adapter : Mydlink, ip : string, pin: string, pinEncrypted: boolean) {\n        super(ip, pin, pinEncrypted);\n        this.adapter = adapter;\n    }\n\n    /**\n     * Create DeviceInfo from ioBroker object, old createDeviceFromConfig (model known)\n     * @param adapter ioBroker Adapter\n     * @param configDevice ioBroker device object\n     * @returns Promise<Device>\n     */\n    static async createFromObject(adapter : Mydlink, configDevice: ioBroker.DeviceObject) : Promise<Device> {\n        const native = configDevice.native;\n        const pinEncrypted = (native.mac && !native.pinNotEncrypted);\n        if (native.model) {\n            return Device.createDevice(adapter, {\n                ip: native.ip,\n                pin: native.pin,\n                pinEncrypted,\n                model: native.model,\n                mac: native.mac,\n                name: native.name,\n                enabled: native.enabled,\n                isWebsocket: native.useWebsocket\n            });\n        } else {\n            adapter.log.info(`Model still unknown for ${native.name}. Trying to identify.`);\n            return Device.createFromTable(adapter, deviceObjetToTableDevice(configDevice), pinEncrypted, native.useWebsocket);\n        }\n    }\n\n    /**\n     * Create a device with model known.\n     * @param adapter\n     * @param params\n     */\n    static async createDevice(adapter: Mydlink, params : {\n        ip: string, pin: string, pinEncrypted: boolean, model: string,\n        pollInterval?: number, mac?: string, id?: string,\n        isWebsocket?: boolean, name?: string, enabled?: boolean}) : Promise<Device> {\n\n        let device;\n        const deviceFlags = KnownDevices[params.model];\n        if (deviceFlags) {\n            device = new deviceFlags.DeviceType(adapter, params.ip, params.pin, params.pinEncrypted);\n        } else {\n            adapter.log.info(`Unknown device type ${params.model} for ${params.name}. Trying to identify.`);\n            if (params.isWebsocket) {\n                device = new WebSocketDevice(adapter, params.ip, params.pin, params.pinEncrypted);\n            } else {\n                device = new SoapDevice(adapter, params.ip, params.pin, params.pinEncrypted);\n            }\n        }\n        device.pollInterval = device.pollInterval || params.pollInterval;\n        device.mac = device.mac || params.mac;\n        device.id = device.id || params.id;\n        device.name = device.name || params.name;\n        device.model = params.model;\n        device.enabled = device.enabled || params.enabled;\n        device.isWebsocket = device.isWebsocket || params.isWebsocket;\n        return device;\n    }\n\n    /**\n     * Creates DeviceInfo from configuration-Table object (model unknown).\n     * @param adapter ioBroker Adapter\n     * @param tableDevice\n     * @param doDecrypt\n     * @returns @returns Promise<Device>\n     */\n    static async createFromTable(adapter : Mydlink, tableDevice: TableDevice, doDecrypt = false, forceWebsocket = false) : Promise<Device> {\n        const pinEncrypted = (doDecrypt && Boolean(tableDevice.mac));\n        const mac = tableDevice.mac ? tableDevice.mac.toUpperCase() : '';\n\n        let device;\n        //first try soap:\n        if (!forceWebsocket) {\n            device = new SoapDevice(adapter, tableDevice.ip, tableDevice.pin, pinEncrypted);\n        } else {\n            device = new WebSocketDevice(adapter, tableDevice.ip, tableDevice.pin, pinEncrypted);\n        }\n\n        device.mac = mac;\n        device.pollInterval = tableDevice.pollInterval !== undefined && isFinite(Number(tableDevice.pollInterval)) && tableDevice.pollInterval >= 0 ? Number(tableDevice.pollInterval) : 30000;\n        if (device.mac) {\n            device.idFromMac();\n        }\n        device.name = tableDevice.name || device.name;\n        device.enabled = tableDevice.enabled !== undefined ? tableDevice.enabled : device.enabled;\n\n        try {\n            await device.login();\n            if (device.loggedIn) {\n                //ok, login worked. -> seems to be soap device, identify:\n                await device.identify();\n            } else {\n                throw new Error('Device not logged in... why?');\n            }\n        } catch (e: any) {\n            device.stop(); //stop old device in any case!\n            const code = processNetworkError(e);\n            if (!forceWebsocket && (code === 500 || code === 'ECONNREFUSED')) { //try websocket.\n                return Device.createFromTable(adapter, tableDevice, doDecrypt, true);\n            }\n\n            if (e.name === WrongModelError.name) {\n                //model was wrong -> recreate with new model information.\n                adapter.log.debug(`Found ${device.model} for ${device.name}. Create a fitting device.`);\n                return Device.createDevice(adapter, {\n                    model: device.model,\n                    ip: device.ip,\n                    pinEncrypted: false,\n                    pin: device.pinDecrypted,\n                    name: device.name,\n                    mac: device.mac,\n                    pollInterval: device.pollInterval,\n                    id: device.id,\n                    isWebsocket: device.isWebsocket,\n                    enabled: device.enabled\n                });\n            }\n\n            if (e.name === WrongMacError.name) {\n                adapter.log.info(`Device with unexpected MAC ${device.mac} reacted on ${device.ip}. Trying to create new device object for it.`);\n                if (device.model) {\n                    return Device.createDevice(adapter, {\n                        model: device.model,\n                        ip: device.ip,\n                        pinEncrypted: false,\n                        pin: device.pinDecrypted,\n                        name: device.name,\n                        mac: device.mac,\n                        pollInterval: device.pollInterval,\n                        id: device.id,\n                        isWebsocket: device.isWebsocket,\n                        enabled: device.enabled\n                    });\n                } else {\n                    return Device.createFromTable(adapter, {\n                        mac: device.mac,\n                        ip: device.ip,\n                        pin: device.pinDecrypted,\n                        name: device.name,\n                        pollInterval: device.pollInterval,\n                        enabled: device.enabled\n                    })\n                }\n            }\n\n            adapter.log.debug('Login error: ' + e.stack);\n            if (!device.loginErrorPrinted && e.code !== 'ETIMEDOUT' && e.code !== 'ECONNABORTED' && e.code !== 'ECONNRESET') {\n                adapter.log.error(tableDevice.name + ' could not login. Please check credentials and if device is online/connected. Error: ' + e.code + ' - ' + e.stack);\n                device.loginErrorPrinted = true;\n            }\n\n            device.loggedIn = false;\n        }\n\n        return device;\n    }\n\n    /**\n     * Stores device configuration as Device Object in ioBroker Database.\n     */\n    async createDeviceObject () : Promise<void> {\n        //do something here.\n        if (!this.id) {\n            if (!this.mac) {\n                this.adapter.log.warn('Could not create device ' + this.name + ' without MAC. Please check config or if device is online.');\n                return;\n            }\n        }\n\n        //also set the native part of the device:\n        await this.adapter.extendObjectAsync(this.id, {\n            type: 'device',\n            common: {\n                name: this.name,\n                statusStates: {\n                    onlineId: `${this.adapter.namespace}.${this.id}.${Suffixes.reachable}`\n                }\n            } as Partial<ioBroker.DeviceCommon>,\n            native: {\n                ip: this.ip,\n                mac: this.mac,\n                pin: this.pinEncrypted,\n                pollInterval: this.pollInterval,\n                enabled: this.enabled,\n                name: this.name,\n                model: this.model,\n                useWebSocket: this.isWebsocket,\n                pinNotEncrypted: false\n            }\n        });\n    }\n\n    /**\n     * Creates state-objects for the device.\n     */\n    async createObjects() : Promise<void> {\n        //enabled indicator:\n        await this.adapter.setObjectNotExistsAsync(this.id + Suffixes.enabled, {\n            type: 'state',\n            common: {\n                name: 'enabled',\n                type: 'boolean',\n                role: 'indicator',\n                read: true,\n                write: false\n            },\n            native: {}\n        });\n\n        //have ready indicator:\n        await this.adapter.setObjectNotExistsAsync(this.id + Suffixes.unreachable, {\n            type: 'state',\n            common: {\n                name: 'unreach',\n                type: 'boolean',\n                role: 'indicator.maintenance.unreach',\n                read: true,\n                write: false\n            },\n            native: {}\n        });\n\n        //have ready indicator:\n        await this.adapter.setObjectNotExistsAsync(this.id + Suffixes.reachable, {\n            type: 'state',\n            common: {\n                name: 'device is reachable',\n                type: 'boolean',\n                role: 'indicator.reachable',\n                read: true,\n                write: false\n            },\n            native: {}\n        });\n    }\n\n    stop() : void {\n        if (this.intervalHandle) {\n            this.adapter.clearTimeout(this.intervalHandle);\n        }\n        if (this.client && typeof this.client.disconnect === 'function') {\n            this.client.disconnect();\n        }\n        this.ready = false;\n        this.loggedIn = false;\n    }\n\n    /**\n     * Starts log in for device. Needs to be done before additional commands can work.\n     **/\n    async login() : Promise<boolean> {\n        try {\n            const loginResult = await this.client.login();\n            if (loginResult === true) {\n                this.adapter.log.debug(`${this.name} successfully logged in: ${loginResult}`);\n                this.loggedIn = true;\n                this.loginErrorPrinted = false;\n            } else {\n                if (!this.loginErrorPrinted) {\n                    this.loginErrorPrinted = true;\n                    this.loggedIn = false;\n                    this.adapter.log.debug('Login error: device returned ' + loginResult + ' - this should not really happen.');\n                    this.adapter.log.error(this.name + ' could not login. Please check credentials and if device is online/connected.');\n                }\n            }\n        } catch (e : any) {\n            this.adapter.log.debug('Login error: ' + e.stack);\n\n            if (!this.loginErrorPrinted && e.code !== 'ETIMEDOUT' && e.code !== 'ECONNABORTED' && e.code !== 'ECONNRESET') {\n                this.adapter.log.error(this.name + ' could not login. Please check credentials and if device is online/connected. Error: ' + e.code + ' - ' + e.stack);\n                this.loginErrorPrinted = true;\n            }\n\n            this.loggedIn = false;\n            if (!this.pollInterval) { //if no polling takes place, need to retry login!\n                if (this.intervalHandle) {\n                    this.adapter.clearTimeout(this.intervalHandle);\n                }\n                this.intervalHandle = this.adapter.setTimeout(() => this.start(), 10000); //retry here if no polling.\n            }\n        }\n        return this.loggedIn;\n    }\n\n    async sendModelInfoToSentry(xmls: Record<string, string>) {\n        if (!KnownDevices[this.model]) {\n            //unknown device -> report to sentry.\n            this.adapter.log.info('Found new device, please report the following (full log from file, please) to developer: ' + JSON.stringify(xmls, null, 2));\n            if (this.adapter.supportsFeature && this.adapter.supportsFeature('PLUGINS')) {\n                const sentryInstance = this.adapter.getPluginInstance('sentry');\n                if (sentryInstance) {\n                    const Sentry = sentryInstance.getSentryObject();\n                    if (Sentry) {\n                        Sentry.withScope((scope : any) => {\n                            scope.setLevel('info');\n                            for (const key of Object.keys(xmls)) {\n                                scope.setExtra(key, xmls[key]);\n                            }\n                            Sentry.captureMessage('Unknown-Device ' + this.model, 'info'); // Level 'info'\n                        });\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Identification of device needs to happen after successful login.\n     * Problem: Maybe needs to create new object of new type. Hm...\n     */\n    async identify() : Promise<boolean> {\n        //for device identification by IP set name to model here:\n        if (!this.name) {\n            this.name = this.model;\n        }\n\n        await this.createObjects();\n        this.identified = true;\n        return this.identified;\n    }\n\n    async handleNetworkError(e: any) : Promise<void> {\n        const code = processNetworkError(e);\n        if (code === 403 || this.ready) {\n            this.loggedIn = false; //login next polling.\n        }\n        this.adapter.log.debug('Error during communication ' + this.name + ': ' + code + ' - ' + e.stack + ' - ' + e.body);\n        this.ready = false;\n        await this.adapter.setStateChangedAsync(this.id + Suffixes.unreachable, true, true);\n        await this.adapter.setStateChangedAsync(this.id + Suffixes.reachable, false, true);\n\n        let connected = false;\n        this.adapter.devices.forEach((device) => { connected = connected || device.ready; }); //turn green if at least one device is ready = reachable.\n        await this.adapter.setStateChangedAsync('info.connection', connected, true);\n    }\n\n    /**\n     * Do polling here.\n     * @returns {Promise<void>}\n     */\n    async onInterval() : Promise<void> {\n        //this.log.debug('Polling ' + this.name);\n        try {\n            if (!this.loggedIn) {\n                await this.login();\n            }\n            if (this.loggedIn && !this.identified) {\n                await this.identify();\n            }\n            if (this.loggedIn && this.identified) {\n                this.ready = await this.client.isDeviceReady();\n                await this.adapter.setStateChangedAsync(this.id + Suffixes.unreachable, !this.ready, true);\n                await this.adapter.setStateAsync(this.id + Suffixes.reachable, this.ready, true);\n\n                //prevent more interaction with device and reset connection.\n                if (this.ready) {\n                    //signal that we could at least reach one device:\n                    await this.adapter.setStateChangedAsync('info.connection', true, true);\n                }\n            }\n        } catch (e: any) {\n            await this.handleNetworkError(e);\n        }\n\n        if (this.pollInterval > 0) { //only start timeout again, if set in settings.\n            this.intervalHandle = this.adapter.setTimeout(() => this.onInterval,\n                this.pollInterval);\n        }\n    }\n\n    /**\n     * starting communication with device from config.\n     * @returns {Promise<boolean>}\n     */\n    async start() : Promise<boolean> {\n        //if device was already started -> stop it.\n        //(use case: ip did change or settings did change)\n        this.stop();\n\n        //interrogate enabled devices\n        //this will get MAC for manually configured devices.\n        if (this.enabled) {\n            //login:\n            await this.login();\n            if (this.loggedIn) {\n                try {\n                    await this.identify();\n                    this.ready = await this.client.isDeviceReady();\n                    await this.adapter.setStateAsync(this.id + Suffixes.reachable, this.ready, true);\n                    await this.adapter.setStateAsync(this.id + Suffixes.unreachable, !this.ready, true);\n                } catch (e: any) {\n                    this.adapter.log.error(this.name + ' could not get settings: ' + e.stack);\n                }\n            }\n        }\n\n        //transfer enabled flag to object:\n        await this.adapter.setStateAsync(this.id + Suffixes.enabled, {val: this.enabled, ack: true});\n\n        //start polling if device is enabled (do this after all is setup).\n        let result = false;\n        if (this.enabled) {\n            //some devices, for example W245, don't push.. so poll websocket also.\n            let interval = this.pollInterval;\n            if (interval !== undefined && !Number.isNaN(interval) && interval > 0) {\n                this.adapter.log.debug('Start polling for ' + this.name + ' with interval ' + interval);\n                result = true; //only use yellow/green states if polling at least one device.\n                if (interval < 500) {\n                    this.adapter.log.warn('Increasing poll rate to twice per second. Please check device config.');\n                    interval = 500; //polling twice every second should be enough, right?\n                }\n                if (interval >= 2147483647) {\n                    interval = 2147483646;\n                    this.adapter.log.warn('Poll rate was too high, reduced to prevent issues.');\n                }\n                this.pollInterval = interval;\n                this.intervalHandle = this.adapter.setTimeout(() => this.onInterval,\n                    this.pollInterval);\n            } else {\n                this.pollInterval = 0;\n                this.adapter.log.debug('Polling of ' + this.name + ' disabled, interval was ' + interval + ' (0 means disabled)');\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * process a state change. Device will just try to switch plug. Childs will have to overwrite this behaviour.\n     * @param _id\n     * @param _state\n     */\n    async handleStateChange(_id : string, _state : ioBroker.State) : Promise<void> {\n        if (this.loggedIn) {\n            await this.login();\n        }\n    }\n\n}\n\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,wBAA2B;AAC3B,sBAAyB;AAEzB,0BAA2B;AAE3B,wBAAyB;AACzB,6BAA8B;AAMvB,MAAM,sBAAsB,MAAM;AAAA,EAErC,YAAY,SAAiB;AACzB,UAAM,OAAO;AAFjB,gBAAO;AAAA,EAGP;AACJ;AAEO,MAAM,wBAAwB,MAAM;AAAA,EAEvC,YAAY,SAAiB;AACzB,UAAM,OAAO;AAFjB,gBAAO;AAAA,EAGP;AACJ;AAOO,SAAS,oBAAoB,GAAwB;AACxD,MAAI,EAAE,UAAU;AAKZ,WAAO,EAAE,SAAS;AAAA,EACtB,WAAW,EAAE,SAAS;AAKlB,WAAO,EAAE;AAAA,EACb,OAAO;AAEH,WAAO,EAAE;AAAA,EACb;AACJ;AAEA,SAAS,yBAAyB,cAAmD;AACjF,SAAO;AAAA,IACH,MAAM,aAAa,OAAO;AAAA,IAC1B,KAAK,aAAa,OAAO;AAAA,IACzB,IAAI,aAAa,OAAO;AAAA,IACxB,KAAK,aAAa,OAAO;AAAA,IACzB,cAAc,aAAa,OAAO;AAAA,IAClC,SAAS,aAAa,OAAO;AAAA,EACjC;AACJ;AAEO,MAAe,eAAe,6BAAW;AAAA,EAG5C,YAAa,SAAmB,IAAa,KAAa,cAAuB;AAC7E,UAAM,IAAI,KAAK,YAAY;AAC3B,SAAK,UAAU;AAAA,EACnB;AAAA,EAQA,aAAa,iBAAiB,SAAmB,cAAuD;AACpG,UAAM,SAAS,aAAa;AAC5B,UAAM,eAAgB,OAAO,OAAO,CAAC,OAAO;AAC5C,QAAI,OAAO,OAAO;AACd,aAAO,OAAO,aAAa,SAAS;AAAA,QAChC,IAAI,OAAO;AAAA,QACX,KAAK,OAAO;AAAA,QACZ;AAAA,QACA,OAAO,OAAO;AAAA,QACd,KAAK,OAAO;AAAA,QACZ,MAAM,OAAO;AAAA,QACb,SAAS,OAAO;AAAA,QAChB,aAAa,OAAO;AAAA,MACxB,CAAC;AAAA,IACL,OAAO;AACH,cAAQ,IAAI,KAAK,2BAA2B,OAAO,2BAA2B;AAC9E,aAAO,OAAO,gBAAgB,SAAS,yBAAyB,YAAY,GAAG,cAAc,OAAO,YAAY;AAAA,IACpH;AAAA,EACJ;AAAA,EAOA,aAAa,aAAa,SAAkB,QAGoC;AAE5E,QAAI;AACJ,UAAM,cAAc,iCAAa,OAAO;AACxC,QAAI,aAAa;AACb,eAAS,IAAI,YAAY,WAAW,SAAS,OAAO,IAAI,OAAO,KAAK,OAAO,YAAY;AAAA,IAC3F,OAAO;AACH,cAAQ,IAAI,KAAK,uBAAuB,OAAO,aAAa,OAAO,2BAA2B;AAC9F,UAAI,OAAO,aAAa;AACpB,iBAAS,IAAI,uCAAgB,SAAS,OAAO,IAAI,OAAO,KAAK,OAAO,YAAY;AAAA,MACpF,OAAO;AACH,iBAAS,IAAI,6BAAW,SAAS,OAAO,IAAI,OAAO,KAAK,OAAO,YAAY;AAAA,MAC/E;AAAA,IACJ;AACA,WAAO,eAAe,OAAO,gBAAgB,OAAO;AACpD,WAAO,MAAM,OAAO,OAAO,OAAO;AAClC,WAAO,KAAK,OAAO,MAAM,OAAO;AAChC,WAAO,OAAO,OAAO,QAAQ,OAAO;AACpC,WAAO,QAAQ,OAAO;AACtB,WAAO,UAAU,OAAO,WAAW,OAAO;AAC1C,WAAO,cAAc,OAAO,eAAe,OAAO;AAClD,WAAO;AAAA,EACX;AAAA,EASA,aAAa,gBAAgB,SAAmB,aAA0B,YAAY,OAAO,iBAAiB,OAAyB;AACnI,UAAM,eAAgB,aAAa,QAAQ,YAAY,GAAG;AAC1D,UAAM,MAAM,YAAY,MAAM,YAAY,IAAI,YAAY,IAAI;AAE9D,QAAI;AAEJ,QAAI,CAAC,gBAAgB;AACjB,eAAS,IAAI,6BAAW,SAAS,YAAY,IAAI,YAAY,KAAK,YAAY;AAAA,IAClF,OAAO;AACH,eAAS,IAAI,uCAAgB,SAAS,YAAY,IAAI,YAAY,KAAK,YAAY;AAAA,IACvF;AAEA,WAAO,MAAM;AACb,WAAO,eAAe,YAAY,iBAAiB,UAAa,SAAS,OAAO,YAAY,YAAY,CAAC,KAAK,YAAY,gBAAgB,IAAI,OAAO,YAAY,YAAY,IAAI;AACjL,QAAI,OAAO,KAAK;AACZ,aAAO,UAAU;AAAA,IACrB;AACA,WAAO,OAAO,YAAY,QAAQ,OAAO;AACzC,WAAO,UAAU,YAAY,YAAY,SAAY,YAAY,UAAU,OAAO;AAElF,QAAI;AACA,YAAM,OAAO,MAAM;AACnB,UAAI,OAAO,UAAU;AAEjB,cAAM,OAAO,SAAS;AAAA,MAC1B,OAAO;AACH,cAAM,IAAI,MAAM,8BAA8B;AAAA,MAClD;AAAA,IACJ,SAAS,GAAP;AACE,aAAO,KAAK;AACZ,YAAM,OAAO,oBAAoB,CAAC;AAClC,UAAI,CAAC,mBAAmB,SAAS,OAAO,SAAS,iBAAiB;AAC9D,eAAO,OAAO,gBAAgB,SAAS,aAAa,WAAW,IAAI;AAAA,MACvE;AAEA,UAAI,EAAE,SAAS,gBAAgB,MAAM;AAEjC,gBAAQ,IAAI,MAAM,SAAS,OAAO,aAAa,OAAO,gCAAgC;AACtF,eAAO,OAAO,aAAa,SAAS;AAAA,UAChC,OAAO,OAAO;AAAA,UACd,IAAI,OAAO;AAAA,UACX,cAAc;AAAA,UACd,KAAK,OAAO;AAAA,UACZ,MAAM,OAAO;AAAA,UACb,KAAK,OAAO;AAAA,UACZ,cAAc,OAAO;AAAA,UACrB,IAAI,OAAO;AAAA,UACX,aAAa,OAAO;AAAA,UACpB,SAAS,OAAO;AAAA,QACpB,CAAC;AAAA,MACL;AAEA,UAAI,EAAE,SAAS,cAAc,MAAM;AAC/B,gBAAQ,IAAI,KAAK,8BAA8B,OAAO,kBAAkB,OAAO,gDAAgD;AAC/H,YAAI,OAAO,OAAO;AACd,iBAAO,OAAO,aAAa,SAAS;AAAA,YAChC,OAAO,OAAO;AAAA,YACd,IAAI,OAAO;AAAA,YACX,cAAc;AAAA,YACd,KAAK,OAAO;AAAA,YACZ,MAAM,OAAO;AAAA,YACb,KAAK,OAAO;AAAA,YACZ,cAAc,OAAO;AAAA,YACrB,IAAI,OAAO;AAAA,YACX,aAAa,OAAO;AAAA,YACpB,SAAS,OAAO;AAAA,UACpB,CAAC;AAAA,QACL,OAAO;AACH,iBAAO,OAAO,gBAAgB,SAAS;AAAA,YACnC,KAAK,OAAO;AAAA,YACZ,IAAI,OAAO;AAAA,YACX,KAAK,OAAO;AAAA,YACZ,MAAM,OAAO;AAAA,YACb,cAAc,OAAO;AAAA,YACrB,SAAS,OAAO;AAAA,UACpB,CAAC;AAAA,QACL;AAAA,MACJ;AAEA,cAAQ,IAAI,MAAM,kBAAkB,EAAE,KAAK;AAC3C,UAAI,CAAC,OAAO,qBAAqB,EAAE,SAAS,eAAe,EAAE,SAAS,kBAAkB,EAAE,SAAS,cAAc;AAC7G,gBAAQ,IAAI,MAAM,YAAY,OAAO,0FAA0F,EAAE,OAAO,QAAQ,EAAE,KAAK;AACvJ,eAAO,oBAAoB;AAAA,MAC/B;AAEA,aAAO,WAAW;AAAA,IACtB;AAEA,WAAO;AAAA,EACX;AAAA,EAKA,MAAM,qBAAsC;AAExC,QAAI,CAAC,KAAK,IAAI;AACV,UAAI,CAAC,KAAK,KAAK;AACX,aAAK,QAAQ,IAAI,KAAK,6BAA6B,KAAK,OAAO,2DAA2D;AAC1H;AAAA,MACJ;AAAA,IACJ;AAGA,UAAM,KAAK,QAAQ,kBAAkB,KAAK,IAAI;AAAA,MAC1C,MAAM;AAAA,MACN,QAAQ;AAAA,QACJ,MAAM,KAAK;AAAA,QACX,cAAc;AAAA,UACV,UAAU,GAAG,KAAK,QAAQ,aAAa,KAAK,MAAM,yBAAS;AAAA,QAC/D;AAAA,MACJ;AAAA,MACA,QAAQ;AAAA,QACJ,IAAI,KAAK;AAAA,QACT,KAAK,KAAK;AAAA,QACV,KAAK,KAAK;AAAA,QACV,cAAc,KAAK;AAAA,QACnB,SAAS,KAAK;AAAA,QACd,MAAM,KAAK;AAAA,QACX,OAAO,KAAK;AAAA,QACZ,cAAc,KAAK;AAAA,QACnB,iBAAiB;AAAA,MACrB;AAAA,IACJ,CAAC;AAAA,EACL;AAAA,EAKA,MAAM,gBAAgC;AAElC,UAAM,KAAK,QAAQ,wBAAwB,KAAK,KAAK,yBAAS,SAAS;AAAA,MACnE,MAAM;AAAA,MACN,QAAQ;AAAA,QACJ,MAAM;AAAA,QACN,MAAM;AAAA,QACN,MAAM;AAAA,QACN,MAAM;AAAA,QACN,OAAO;AAAA,MACX;AAAA,MACA,QAAQ,CAAC;AAAA,IACb,CAAC;AAGD,UAAM,KAAK,QAAQ,wBAAwB,KAAK,KAAK,yBAAS,aAAa;AAAA,MACvE,MAAM;AAAA,MACN,QAAQ;AAAA,QACJ,MAAM;AAAA,QACN,MAAM;AAAA,QACN,MAAM;AAAA,QACN,MAAM;AAAA,QACN,OAAO;AAAA,MACX;AAAA,MACA,QAAQ,CAAC;AAAA,IACb,CAAC;AAGD,UAAM,KAAK,QAAQ,wBAAwB,KAAK,KAAK,yBAAS,WAAW;AAAA,MACrE,MAAM;AAAA,MACN,QAAQ;AAAA,QACJ,MAAM;AAAA,QACN,MAAM;AAAA,QACN,MAAM;AAAA,QACN,MAAM;AAAA,QACN,OAAO;AAAA,MACX;AAAA,MACA,QAAQ,CAAC;AAAA,IACb,CAAC;AAAA,EACL;AAAA,EAEA,OAAc;AACV,QAAI,KAAK,gBAAgB;AACrB,WAAK,QAAQ,aAAa,KAAK,cAAc;AAAA,IACjD;AACA,QAAI,KAAK,UAAU,OAAO,KAAK,OAAO,eAAe,YAAY;AAC7D,WAAK,OAAO,WAAW;AAAA,IAC3B;AACA,SAAK,QAAQ;AACb,SAAK,WAAW;AAAA,EACpB;AAAA,EAKA,MAAM,QAA2B;AAC7B,QAAI;AACA,YAAM,cAAc,MAAM,KAAK,OAAO,MAAM;AAC5C,UAAI,gBAAgB,MAAM;AACtB,aAAK,QAAQ,IAAI,MAAM,GAAG,KAAK,gCAAgC,aAAa;AAC5E,aAAK,WAAW;AAChB,aAAK,oBAAoB;AAAA,MAC7B,OAAO;AACH,YAAI,CAAC,KAAK,mBAAmB;AACzB,eAAK,oBAAoB;AACzB,eAAK,WAAW;AAChB,eAAK,QAAQ,IAAI,MAAM,kCAAkC,cAAc,mCAAmC;AAC1G,eAAK,QAAQ,IAAI,MAAM,KAAK,OAAO,+EAA+E;AAAA,QACtH;AAAA,MACJ;AAAA,IACJ,SAAS,GAAP;AACE,WAAK,QAAQ,IAAI,MAAM,kBAAkB,EAAE,KAAK;AAEhD,UAAI,CAAC,KAAK,qBAAqB,EAAE,SAAS,eAAe,EAAE,SAAS,kBAAkB,EAAE,SAAS,cAAc;AAC3G,aAAK,QAAQ,IAAI,MAAM,KAAK,OAAO,0FAA0F,EAAE,OAAO,QAAQ,EAAE,KAAK;AACrJ,aAAK,oBAAoB;AAAA,MAC7B;AAEA,WAAK,WAAW;AAChB,UAAI,CAAC,KAAK,cAAc;AACpB,YAAI,KAAK,gBAAgB;AACrB,eAAK,QAAQ,aAAa,KAAK,cAAc;AAAA,QACjD;AACA,aAAK,iBAAiB,KAAK,QAAQ,WAAW,MAAM,KAAK,MAAM,GAAG,GAAK;AAAA,MAC3E;AAAA,IACJ;AACA,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,MAAM,sBAAsB,MAA8B;AACtD,QAAI,CAAC,iCAAa,KAAK,QAAQ;AAE3B,WAAK,QAAQ,IAAI,KAAK,8FAA8F,KAAK,UAAU,MAAM,MAAM,CAAC,CAAC;AACjJ,UAAI,KAAK,QAAQ,mBAAmB,KAAK,QAAQ,gBAAgB,SAAS,GAAG;AACzE,cAAM,iBAAiB,KAAK,QAAQ,kBAAkB,QAAQ;AAC9D,YAAI,gBAAgB;AAChB,gBAAM,SAAS,eAAe,gBAAgB;AAC9C,cAAI,QAAQ;AACR,mBAAO,UAAU,CAAC,UAAgB;AAC9B,oBAAM,SAAS,MAAM;AACrB,yBAAW,OAAO,OAAO,KAAK,IAAI,GAAG;AACjC,sBAAM,SAAS,KAAK,KAAK,IAAI;AAAA,cACjC;AACA,qBAAO,eAAe,oBAAoB,KAAK,OAAO,MAAM;AAAA,YAChE,CAAC;AAAA,UACL;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AAAA,EAMA,MAAM,WAA8B;AAEhC,QAAI,CAAC,KAAK,MAAM;AACZ,WAAK,OAAO,KAAK;AAAA,IACrB;AAEA,UAAM,KAAK,cAAc;AACzB,SAAK,aAAa;AAClB,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,MAAM,mBAAmB,GAAwB;AAC7C,UAAM,OAAO,oBAAoB,CAAC;AAClC,QAAI,SAAS,OAAO,KAAK,OAAO;AAC5B,WAAK,WAAW;AAAA,IACpB;AACA,SAAK,QAAQ,IAAI,MAAM,gCAAgC,KAAK,OAAO,OAAO,OAAO,QAAQ,EAAE,QAAQ,QAAQ,EAAE,IAAI;AACjH,SAAK,QAAQ;AACb,UAAM,KAAK,QAAQ,qBAAqB,KAAK,KAAK,yBAAS,aAAa,MAAM,IAAI;AAClF,UAAM,KAAK,QAAQ,qBAAqB,KAAK,KAAK,yBAAS,WAAW,OAAO,IAAI;AAEjF,QAAI,YAAY;AAChB,SAAK,QAAQ,QAAQ,QAAQ,CAAC,WAAW;AAAE,kBAAY,aAAa,OAAO;AAAA,IAAO,CAAC;AACnF,UAAM,KAAK,QAAQ,qBAAqB,mBAAmB,WAAW,IAAI;AAAA,EAC9E;AAAA,EAMA,MAAM,aAA6B;AAE/B,QAAI;AACA,UAAI,CAAC,KAAK,UAAU;AAChB,cAAM,KAAK,MAAM;AAAA,MACrB;AACA,UAAI,KAAK,YAAY,CAAC,KAAK,YAAY;AACnC,cAAM,KAAK,SAAS;AAAA,MACxB;AACA,UAAI,KAAK,YAAY,KAAK,YAAY;AAClC,aAAK,QAAQ,MAAM,KAAK,OAAO,cAAc;AAC7C,cAAM,KAAK,QAAQ,qBAAqB,KAAK,KAAK,yBAAS,aAAa,CAAC,KAAK,OAAO,IAAI;AACzF,cAAM,KAAK,QAAQ,cAAc,KAAK,KAAK,yBAAS,WAAW,KAAK,OAAO,IAAI;AAG/E,YAAI,KAAK,OAAO;AAEZ,gBAAM,KAAK,QAAQ,qBAAqB,mBAAmB,MAAM,IAAI;AAAA,QACzE;AAAA,MACJ;AAAA,IACJ,SAAS,GAAP;AACE,YAAM,KAAK,mBAAmB,CAAC;AAAA,IACnC;AAEA,QAAI,KAAK,eAAe,GAAG;AACvB,WAAK,iBAAiB,KAAK,QAAQ;AAAA,QAAW,MAAM,KAAK;AAAA,QACrD,KAAK;AAAA,MAAY;AAAA,IACzB;AAAA,EACJ;AAAA,EAMA,MAAM,QAA2B;AAG7B,SAAK,KAAK;AAIV,QAAI,KAAK,SAAS;AAEd,YAAM,KAAK,MAAM;AACjB,UAAI,KAAK,UAAU;AACf,YAAI;AACA,gBAAM,KAAK,SAAS;AACpB,eAAK,QAAQ,MAAM,KAAK,OAAO,cAAc;AAC7C,gBAAM,KAAK,QAAQ,cAAc,KAAK,KAAK,yBAAS,WAAW,KAAK,OAAO,IAAI;AAC/E,gBAAM,KAAK,QAAQ,cAAc,KAAK,KAAK,yBAAS,aAAa,CAAC,KAAK,OAAO,IAAI;AAAA,QACtF,SAAS,GAAP;AACE,eAAK,QAAQ,IAAI,MAAM,KAAK,OAAO,8BAA8B,EAAE,KAAK;AAAA,QAC5E;AAAA,MACJ;AAAA,IACJ;AAGA,UAAM,KAAK,QAAQ,cAAc,KAAK,KAAK,yBAAS,SAAS,EAAC,KAAK,KAAK,SAAS,KAAK,KAAI,CAAC;AAG3F,QAAI,SAAS;AACb,QAAI,KAAK,SAAS;AAEd,UAAI,WAAW,KAAK;AACpB,UAAI,aAAa,UAAa,CAAC,OAAO,MAAM,QAAQ,KAAK,WAAW,GAAG;AACnE,aAAK,QAAQ,IAAI,MAAM,uBAAuB,KAAK,OAAO,oBAAoB,QAAQ;AACtF,iBAAS;AACT,YAAI,WAAW,KAAK;AAChB,eAAK,QAAQ,IAAI,KAAK,uEAAuE;AAC7F,qBAAW;AAAA,QACf;AACA,YAAI,YAAY,YAAY;AACxB,qBAAW;AACX,eAAK,QAAQ,IAAI,KAAK,oDAAoD;AAAA,QAC9E;AACA,aAAK,eAAe;AACpB,aAAK,iBAAiB,KAAK,QAAQ;AAAA,UAAW,MAAM,KAAK;AAAA,UACrD,KAAK;AAAA,QAAY;AAAA,MACzB,OAAO;AACH,aAAK,eAAe;AACpB,aAAK,QAAQ,IAAI,MAAM,gBAAgB,KAAK,OAAO,6BAA6B,WAAW,qBAAqB;AAAA,MACpH;AAAA,IACJ;AAEA,WAAO;AAAA,EACX;AAAA,EAOA,MAAM,kBAAkB,KAAc,QAAyC;AAC3E,QAAI,KAAK,UAAU;AACf,YAAM,KAAK,MAAM;AAAA,IACrB;AAAA,EACJ;AAEJ;",
  "names": []
}
