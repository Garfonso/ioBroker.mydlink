{
  "version": 3,
  "sources": ["../../src/lib/soapDevice.ts"],
  "sourcesContent": ["\nimport {Device, WrongMacError, WrongModelError} from './Device';\nimport { Suffixes } from './suffixes';\nimport { SoapClientInterface } from './Clients';\nimport createSoapClient from './soapclient';\nimport { Mydlink } from './mydlink';\n\nexport class SoapDevice extends Device {\n    client: SoapClientInterface;\n\n    constructor(adapter : Mydlink, ip: string, pin: string, pinEncrypted: boolean) {\n        super(adapter, ip, pin, pinEncrypted);\n\n        //does only setup soapClient -> no connection, yet.\n        this.client = createSoapClient({\n            user: 'Admin',\n            password: this.pinDecrypted,\n            url: 'http://' + this.ip + '/HNAP1'\n        }) as SoapClientInterface;\n    }\n\n    /**\n     * Creates objects for the device.\n     */\n    async createObjects() : Promise<void> {\n        await super.createObjects();\n        //create state object, for plug this is writable for sensor not.\n        await this.adapter.setObjectNotExistsAsync(this.id + Suffixes.reboot, {\n            type: 'state',\n            common: {\n                name: 'reboot device',\n                type: 'boolean',\n                role: 'button',\n                read: false,\n                write: true\n            },\n            native: {}\n        });\n        await this.adapter.subscribeStatesAsync(this.id + Suffixes.reboot);\n    }\n\n    /**\n     * process a state change. Device will just try to switch plug. Childs will have to overwrite this behaviour.\n     * @param id\n     * @param _state\n     */\n    async handleStateChange(id : string, _state : ioBroker.State) : Promise<void> {\n        if (this.loggedIn) {\n            await this.login();\n        }\n\n        if (id.endsWith(Suffixes.reboot)) {\n            try {\n                await this.client.reboot();\n                this.adapter.log.debug(`Send reboot request to ${this.name}`);\n            } catch(e: any) {\n                await this.handleNetworkError(e);\n            }\n        }\n    }\n\n    async identify() : Promise<boolean> {\n        const settings = await this.client.getDeviceSettings();\n        let dirty = false;\n        this.adapter.log.debug(this.name + ' returned following device settings: ' + JSON.stringify(settings, null, 2));\n        if (this.mac && this.mac !== settings.DeviceMacId) {\n            throw new WrongMacError(`${this.name} reported mac ${settings.DeviceMacId}, expected ${this.mac}, probably ip ${this.ip} wrong and talking to wrong device?`);\n        }\n        if (this.mac !== settings.DeviceMacId) {\n            this.mac = (settings.DeviceMacId as string).toUpperCase();\n            dirty = true;\n        }\n\n        if (this.model && this.model !== settings.ModelName) {\n            this.model = settings.ModelName as string;\n            this.adapter.log.warn(`${this.name} model changed from ${this.model} to ${settings.ModelName}`);\n            throw new WrongModelError(`${this.name} model changed from ${this.model} to ${settings.ModelName}`);\n        }\n        if (this.model !== settings.ModelName) {\n            this.model = settings.ModelName as string;\n            dirty = true;\n        }\n\n        //let canSwitch = this.model.toUpperCase().includes('DSP') ||\n        //    ((settings.ModuleTypes as Array<string>).find(t => t.indexOf('Plug') >= 0)); //if is socket, probably can switch on/off\n\n        if (dirty) {\n            await this.createDeviceObject();\n        }\n\n        return super.identify();\n    }\n}\n\nexport class SoapSwitch extends SoapDevice {\n    //currently only know DSP-W215 as soap switch which has all those.\n    hasTemp = true;\n    hasPower = true;\n    hasTotalPower = true;\n\n    /**\n     * Creates objects for the device.\n     */\n    async createObjects() : Promise<void> {\n        await super.createObjects();\n        //create state object, for plug this is writable\n        await this.adapter.setObjectNotExistsAsync(this.id + Suffixes.state, {\n            type: 'state',\n            common: {\n                name: 'state of plug',\n                type: 'boolean',\n                role: 'switch',\n                read: true,\n                write: true\n            },\n            native: {}\n        });\n        await this.adapter.subscribeStatesAsync(this.id + Suffixes.state);\n\n        //currently only know DSP-W215 which has Power & Temperature -> so create here every time.\n        //if another socket without those measurements is added, need flags here.\n        await this.adapter.setObjectNotExistsAsync(this.id + Suffixes.temperature, {\n            type: 'state',\n            common: {\n                name: 'temperature',\n                type: 'number',\n                role: 'value.temperature',\n                unit: '\u00B0C',\n                read: true,\n                write: false\n            },\n            native: {}\n        });\n\n        await this.adapter.setObjectNotExistsAsync(this.id + Suffixes.power, {\n            type: 'state',\n            common: {\n                name: 'currentPowerConsumption',\n                type: 'number',\n                role: 'value.power',\n                unit: 'W',\n                read: true,\n                write: false\n            },\n            native: {}\n        });\n\n        await this.adapter.setObjectNotExistsAsync(this.id + Suffixes.totalPower, {\n            type: 'state',\n            common: {\n                name: 'totalPowerConsumption',\n                type: 'number',\n                role: 'value.energy.consumed',\n                unit: 'kWh',\n                read: true,\n                write: false\n            },\n            native: {}\n        });\n    }\n\n    /**\n     * Do polling here.\n     * @returns {Promise<void>}\n     */\n    async onInterval() : Promise<void> {\n        await super.onInterval();\n        // if not ready -> communication did fail, will be retried on next poll.\n        if (this.ready) {\n            //check switch status:\n            try {\n                const val = await this.client.state() as boolean;\n                await this.adapter.setStateChangedAsync(this.id + Suffixes.state, val, true);\n\n                if (this.hasTemp) {\n                    const temp = await this.client.temperature();\n                    await this.adapter.setStateChangedAsync(this.id + Suffixes.temperature, temp, true);\n                }\n                if (this.hasPower) {\n                    const power = await this.client.consumption();\n                    await this.adapter.setStateChangedAsync(this.id + Suffixes.power, power, true);\n                }\n                if (this.hasTotalPower) {\n                    const totalPower = await this.client.totalConsumption();\n                    await this.adapter.setStateChangedAsync(this.id + Suffixes.power, totalPower, true);\n                }\n            } catch (e: any) {\n                await this.handleNetworkError(e);\n            }\n        }\n    }\n\n    /**\n     * process a state change. Device will just try to switch plug. Childs will have to overwrite this behaviour.\n     * @param id\n     * @param state\n     */\n    async handleStateChange(id : string, state : ioBroker.State) : Promise<void> {\n        await super.handleStateChange(id, state);\n\n        if (typeof state.val === 'boolean') {\n            if (id.endsWith(Suffixes.state)) {\n                try {\n                    await this.client.switch(state.val);\n                    const newVal = (await this.client.state()) as boolean;\n                    await this.adapter.setStateAsync(id, newVal, true);\n                } catch(e: any) {\n                    await this.handleNetworkError(e);\n                }\n            }\n        } else {\n            this.adapter.log.warn('Wrong state type. Only boolean accepted for switch.');\n        }\n    }\n}\n\nexport class SoapMotionDetector extends SoapDevice {\n    /**\n     * Do polling here.\n     * @returns {Promise<void>}\n     */\n    async onInterval() : Promise<void> {\n        await super.onInterval();\n        // if not ready -> communication did fail, will be retried on next poll.\n        if (this.ready) {\n            try {\n                const lastDetection = await this.client.lastDetection();\n                //const notChanged = await new Promise<boolean>((resolve, reject) => this.adapter.setStateChanged(this.id + Suffixes.lastDetected, lastDetection, true, (err: any, _id: string, notChanged: boolean) => err ? reject(err) : resolve(notChanged)));\n                const notChanged = await new Promise<boolean>((resolve, reject) => this.adapter.setStateChanged(this.id + Suffixes.lastDetected, lastDetection, true, (err, _id, notChanged) => err ? reject(err) : resolve(notChanged || false)));\n                if (!notChanged) {\n                    //timestamp did change -> we had a new detection!\n                    await this.adapter.setStateAsync(this.id + Suffixes.state, true, true);\n                } else {\n                    await this.adapter.setStateChangedAsync(this.id + Suffixes.state, false, true);\n                }\n                const noMotion = Math.round((Date.now() - lastDetection) / 1000);\n                await this.adapter.setStateChangedAsync(this.id + Suffixes.noMotion, noMotion, true);\n            } catch (e: any) {\n                await this.handleNetworkError(e);\n            }\n        }\n    }\n\n    /**\n     * Creates objects for the device.\n     */\n    async createObjects() : Promise<void> {\n        await super.createObjects();\n        await this.adapter.setObjectNotExistsAsync(this.id + Suffixes.state, {\n            type: 'state',\n            common: {\n                name: 'state',\n                type: 'boolean',\n                role: 'sensor.motion',\n                read: true,\n                write: false\n            },\n            native: {}\n        });\n\n        await this.adapter.setObjectNotExistsAsync(this.id + Suffixes.noMotion, {\n            type: 'state',\n            common: {\n                name: 'No motion since',\n                type: 'number',\n                role: 'value.interval',\n                unit: 'seconds',\n                read: true,\n                write: false\n            },\n            native: {}\n        });\n\n        await this.adapter.setObjectNotExistsAsync(this.id + Suffixes.lastDetected, {\n            type: 'state',\n            common: {\n                name: 'lastDetected',\n                type: 'number',\n                role: 'value.time',\n                read: true,\n                write: false\n            },\n            native: {}\n        });\n    }\n}\n"],
  "mappings": "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",
  "names": ["createSoapClient", "notChanged"]
}
